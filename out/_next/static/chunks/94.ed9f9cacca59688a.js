"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[94],{86094:function(a,b,c){c.r(b),c.d(b,{OpenloginAdapter:function(){return m},getOpenloginDefaultOptions:function(){return j}});var d=c(3388),e=c(45624),f=c(4942),g=c(67845),h=c(72378),i=c.n(h);let j=(a,b)=>({adapterSettings:{network:d.dr.MAINNET,clientId:"",uxMode:d.$e.POPUP},chainConfig:a?(0,e.h2)(a,b):null,loginSettings:{}});function k(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function l(a){for(var b=1;b<arguments.length;b++){var c=null!=arguments[b]?arguments[b]:{};b%2?k(Object(c),!0).forEach(function(b){(0,f.Z)(a,b,c[b])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(c)):k(Object(c)).forEach(function(b){Object.defineProperty(a,b,Object.getOwnPropertyDescriptor(c,b))})}return a}class m extends e.J5{constructor(a){var b,c,g,h;super(),(0,f.Z)(this,"name",e.rW.OPENLOGIN),(0,f.Z)(this,"adapterNamespace",e.yk.MULTICHAIN),(0,f.Z)(this,"type",e.hN.IN_APP),(0,f.Z)(this,"openloginInstance",null),(0,f.Z)(this,"status",e.MP.NOT_READY),(0,f.Z)(this,"currentChainNamespace",e.EN.EIP155),(0,f.Z)(this,"openloginOptions",void 0),(0,f.Z)(this,"loginSettings",{}),(0,f.Z)(this,"privKeyProvider",null),e.cM.debug("const openlogin adapter",a);let i=j(null===(b=a.chainConfig)|| void 0===b?void 0:b.chainNamespace,null===(c=a.chainConfig)|| void 0===c?void 0:c.chainId);if(this.openloginOptions=l(l({clientId:"",network:d.dr.MAINNET},i.adapterSettings),a.adapterSettings||{}),this.loginSettings=l(l({},i.loginSettings),a.loginSettings),this.sessionTime=this.loginSettings.sessionTime||86400,null!==(g=a.chainConfig)&& void 0!==g&&g.chainNamespace){this.currentChainNamespace=null===(h=a.chainConfig)|| void 0===h?void 0:h.chainNamespace;let k=i.chainConfig?i.chainConfig:{};if(this.chainConfig=l(l({},k),null==a?void 0:a.chainConfig),e.cM.debug("const openlogin chainConfig",this.chainConfig),!this.chainConfig.rpcTarget&&a.chainConfig.chainNamespace!==e.EN.OTHER)throw e.Ty.invalidParams("rpcTarget is required in chainConfig")}}get chainConfigProxy(){return this.chainConfig?l({},this.chainConfig):null}get provider(){var a;return(null===(a=this.privKeyProvider)|| void 0===a?void 0:a.provider)||null}set provider(a){throw Error("Not implemented")}async init(a){var b;if(super.checkInitializationRequirements(),!(null!==(b=this.openloginOptions)&& void 0!==b&&b.clientId))throw e.Ty.invalidParams("clientId is required before openlogin's initialization");if(!this.chainConfig)throw e.Ty.invalidParams("chainConfig is required before initialization");let c=!1;if(this.openloginOptions.uxMode===d.$e.REDIRECT){let f=(0,d.Gv)();Object.keys(f).length>0&&f._pid&&(c=!0)}this.openloginOptions=l(l({},this.openloginOptions),{},{replaceUrlOnRedirect:c}),this.openloginInstance=new d.ZP(this.openloginOptions),e.cM.debug("initializing openlogin adapter init"),await this.openloginInstance.init(),this.status=e.MP.READY,this.emit(e.n2.READY,e.rW.OPENLOGIN);try{e.cM.debug("initializing openlogin adapter"),this.openloginInstance.privKey&&(a.autoConnect||c)&&await this.connect()}catch(g){e.cM.error("Failed to connect with cached openlogin provider",g),this.emit("ERRORED",g)}}async connect(a){super.checkConnectionRequirements(),this.status=e.MP.CONNECTING,this.emit(e.n2.CONNECTING,l(l({},a),{},{adapter:e.rW.OPENLOGIN}));try{return await this.connectWithProvider(a),this.provider}catch(b){if(e.cM.error("Failed to connect with openlogin provider",b),this.status=e.MP.READY,this.emit(e.n2.ERRORED,b),null!=b&&b.message.includes("user closed popup"))throw e.RM.popupClosed();throw e.RM.connectionError("Failed to login with openlogin")}}async disconnect(){let a=arguments.length>0&& void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==e.MP.CONNECTED)throw e.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw e.Ty.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),a.cleanup?(this.status=e.MP.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=e.MP.READY,this.emit(e.n2.DISCONNECTED)}async authenticateUser(){if(this.status!==e.MP.CONNECTED)throw e.RM.notConnectedError("Not connected with wallet, Please login/connect first");let a=await this.getUserInfo();return{idToken:a.idToken}}async getUserInfo(){if(this.status!==e.MP.CONNECTED)throw e.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw e.Ty.notReady("openloginInstance is not ready");let a=await this.openloginInstance.getUserInfo();return a}setAdapterSettings(a){if(this.status===e.MP.READY)return;let b=j();this.openloginOptions=l(l(l({},b.adapterSettings),this.openloginOptions||{}),a),a.sessionTime&&(this.loginSettings=l(l({},this.loginSettings),{},{sessionTime:a.sessionTime}))}setChainConfig(a){super.setChainConfig(a),this.currentChainNamespace=a.chainNamespace}async connectWithProvider(a){if(!this.chainConfig)throw e.Ty.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw e.Ty.notReady("openloginInstance is not ready");if(this.currentChainNamespace===e.EN.SOLANA){let{SolanaPrivateKeyProvider:b}=await Promise.all([c.e(766),c.e(108),c.e(119),c.e(297)]).then(c.bind(c,44445));this.privKeyProvider=new b({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===e.EN.EIP155){let{EthereumPrivateKeyProvider:f}=await Promise.all([c.e(482),c.e(62),c.e(755)]).then(c.bind(c,52062));this.privKeyProvider=new f({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===e.EN.OTHER)this.privKeyProvider=new g.FL;else throw Error("Invalid chainNamespace: ".concat(this.currentChainNamespace," found while connecting to wallet"));if(!this.openloginInstance.privKey&&a){var h;this.loginSettings.curve||(this.loginSettings.curve=this.currentChainNamespace===e.EN.SOLANA?d.x7.ED25519:d.x7.SECP256K1),await this.openloginInstance.login(i()(this.loginSettings,{loginProvider:a.loginProvider},{extraLoginOptions:l(l({},a.extraLoginOptions||{}),{},{login_hint:a.login_hint||(null===(h=a.extraLoginOptions)|| void 0===h?void 0:h.login_hint)})}))}let j=this.openloginInstance.privKey;if(j){if(this.currentChainNamespace===e.EN.SOLANA){let{getED25519Key:k}=await Promise.all([c.e(108),c.e(418)]).then(c.bind(c,33946));j=k(j).sk.toString("hex")}await this.privKeyProvider.setupProvider(j),this.status=e.MP.CONNECTED,this.emit(e.n2.CONNECTED,{adapter:e.rW.OPENLOGIN,reconnected:!a})}}}}}])