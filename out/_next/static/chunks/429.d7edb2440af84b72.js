"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[429],{92003:function(a){a.exports=function({mustBeMetaMask:a=!1,silent:b=!1,timeout:c=3e3}={}){if("boolean"!=typeof a)throw Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");if("boolean"!=typeof b)throw Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");if("number"!=typeof c)throw Error("@metamask/detect-provider: Expected option 'timeout' to be a number.");let d=!1;return new Promise(e=>{window.ethereum?f():(window.addEventListener("ethereum#initialized",f,{once:!0}),setTimeout(()=>{f()},c));function f(){if(d)return;d=!0,window.removeEventListener("ethereum#initialized",f);let{ethereum:c}=window;if(c&&(!a||c.isMetaMask))e(c);else{let g=a&&c?"Non-MetaMask window.ethereum detected.":"Unable to detect window.ethereum.";b||console.error("@metamask/detect-provider:",g),e(null)}}})}},35796:function(a,b,c){c.d(b,{d:function(){return e}});var d=c(45624);class e extends d.J5{async authenticateUser(){var a;if(!this.provider||!(null!==(a=this.chainConfig)&& void 0!==a&&a.chainId))throw d.RM.notConnectedError();let{chainNamespace:b,chainId:c}=this.chainConfig;if(this.status!==d.MP.CONNECTED)throw d.RM.notConnectedError("Not connected with wallet, Please login/connect first");let e=await this.provider.request({method:"eth_accounts"});if(e&&e.length>0){let f=(0,d.Cb)(e[0],this.name);if(f){let g=(0,d.$E)(f);if(!g)return{idToken:f}}let h={domain:window.location.origin,uri:window.location.href,address:e[0],chainId:parseInt(c,16),version:"1",nonce:Math.random().toString(36).slice(2),issuedAt:new Date().toISOString()},i=await (0,d.tV)(h,b),j=await this.provider.request({method:"personal_sign",params:[i,e[0]]}),k=await (0,d.rn)(b,j,i,this.name,this.sessionTime);return(0,d.Fr)(e[0],this.name,k),{idToken:k}}throw d.RM.notConnectedError("Not connected with wallet, Please login/connect first")}async disconnect(){if(this.status!==d.MP.CONNECTED)throw d.RM.disconnectionError("Not connected with wallet");let a=await this.provider.request({method:"eth_accounts"});a&&a.length>0&&(0,d.qz)(a[0],this.name)}}},94429:function(a,b,c){c.r(b),c.d(b,{MetamaskAdapter:function(){return i}});var d=c(4942),e=c(92003),f=c.n(e),g=c(45624),h=c(35796);class i extends h.d{constructor(){let a=arguments.length>0&& void 0!==arguments[0]?arguments[0]:{};super(),(0,d.Z)(this,"adapterNamespace",g.yk.EIP155),(0,d.Z)(this,"currentChainNamespace",g.EN.EIP155),(0,d.Z)(this,"type",g.hN.EXTERNAL),(0,d.Z)(this,"name",g.rW.METAMASK),(0,d.Z)(this,"status",g.MP.NOT_READY),(0,d.Z)(this,"rehydrated",!1),(0,d.Z)(this,"metamaskProvider",null),this.chainConfig=a.chainConfig||null,this.sessionTime=a.sessionTime||86400}get provider(){return this.status===g.MP.CONNECTED&&this.metamaskProvider?this.metamaskProvider:null}set provider(a){throw Error("Not implemented")}async init(a){if(super.checkInitializationRequirements(),this.metamaskProvider=await f()({mustBeMetaMask:!0}),!this.metamaskProvider)throw g.Ty.notInstalled("Metamask extension is not installed");this.status=g.MP.READY,this.emit(g.n2.READY,g.rW.METAMASK);try{g.cM.debug("initializing metamask adapter"),a.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(b){this.emit(g.n2.ERRORED,b)}}setAdapterSettings(a){this.status!==g.MP.READY&&null!=a&&a.sessionTime&&(this.sessionTime=a.sessionTime)}async connect(){if(super.checkConnectionRequirements(),this.chainConfig||(this.chainConfig=(0,g.h2)(g.EN.EIP155,1)),this.status=g.MP.CONNECTING,this.emit(g.n2.CONNECTING,{adapter:g.rW.METAMASK}),!this.metamaskProvider)throw g.RM.notConnectedError("Not able to connect with metamask");try{await this.metamaskProvider.request({method:"eth_requestAccounts"});let{chainId:a}=this.metamaskProvider;if(a!==this.chainConfig.chainId&&await this.switchChain(this.chainConfig),this.status=g.MP.CONNECTED,!this.provider)throw g.RM.notConnectedError("Failed to connect with provider");return this.provider.once("disconnect",()=>{this.disconnect()}),this.emit(g.n2.CONNECTED,{adapter:g.rW.METAMASK,reconnected:this.rehydrated}),this.provider}catch(b){throw this.status=g.MP.READY,this.rehydrated=!1,this.emit(g.n2.ERRORED,b),g.RM.connectionError("Failed to login with metamask wallet")}}async disconnect(){var a;let b=arguments.length>0&& void 0!==arguments[0]?arguments[0]:{cleanup:!1};await super.disconnect(),null===(a=this.provider)|| void 0===a||a.removeAllListeners(),b.cleanup?(this.status=g.MP.NOT_READY,this.metamaskProvider=null):this.status=g.MP.READY,this.rehydrated=!1,this.emit(g.n2.DISCONNECTED)}async getUserInfo(){if(this.status!==g.MP.CONNECTED)throw g.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async switchChain(a){if(!this.metamaskProvider)throw g.RM.notConnectedError("Not connected with wallet");try{await this.metamaskProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:a.chainId}]})}catch(b){if(4902===b.code)await this.metamaskProvider.request({method:"wallet_addEthereumChain",params:[{chainId:a.chainId,chainName:a.displayName,rpcUrls:[a.rpcTarget]}]});else throw b}}}}}])